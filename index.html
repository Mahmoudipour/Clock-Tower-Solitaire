<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clock Tower Solitaire</title>
    
    <!-- PWA/App-like Appearance Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1f2937">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the circular layout */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark gray background */
            display: flex;
            flex-direction: column; 
            justify-content: flex-start; 
            align-items: center;
            min-height: 100vh; 
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            overflow-y: auto;
        }

        #app {
            max-width: 900px;
            width: 95vw;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #game-area {
            position: relative;
            width: 100%; 
            max-width: 800px; 
            aspect-ratio: 1 / 1;
            margin: 1rem auto; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .clock-position {
            position: absolute;
            width: 80px; /* Standard card width */
            min-height: 120px; /* Minimum height for one card, will expand for stack */
            /* Add max height to prevent stacks from growing too big on huge screens */
            max-height: 160px; /* Increased max height to accommodate larger offset */
            transform-origin: 50% 50%;
        }

        /* Center stack container setup */
        .center-stack-container {
            width: 80px;
            min-height: 120px; /* Minimum height for one card, will expand for stack */
            margin: 0 10px;
            position: relative; 
            transition: all 0.2s ease;
            cursor: default; 
            /* Ensure the text below the stack is pushed down */
            display: flex;
            flex-direction: column; 
            justify-content: flex-end; 
        }
        
        /* New: Styles for cards within a stack (both clock and center) */
        .card-in-stack {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 120px; /* Cards have a fixed height of 120px */
            transition: all 0.2s ease;
            border-radius: 8px; /* Maintain rounded corners */
            box-sizing: border-box;
        }
        
        /* The base card stack placeholder for empty positions */
        .card-stack {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 120px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            background-color: #374151; /* Dark gray for empty or base stack */
            border: 2px dashed #4b5563;
        }


        .card {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0;
            box-sizing: border-box;
            background-color: white;
            color: #333;
            border-radius: 8px;
            border: 1px solid #aaa;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            cursor: default; 
            touch-action: none; 
            position: relative; 
        }
        
        .card-in-stack.draggable > .card {
            cursor: grab; /* Only the top card in a stack that is playable is draggable */
        }
        
        /* Ensures inner elements of the card (like suit/rank spans) don't capture the click/touch event. */
        .card > * {
            pointer-events: none;
        }

        .card-in-stack.dragging {
            cursor: grabbing;
            z-index: 10000 !important; /* Ensure it stays on top of everything */
            opacity: 0.85;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.7);
            transition: none; 
            pointer-events: none; 
        }
        
        .card.face-down {
            background-color: #b91c1c; /* Red back */
            border: 4px solid #fca5a5; /* Light red border */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            color: #fca5a5;
            font-size: 2rem;
            align-items: center;
            justify-content: center;
            user-select: none;
            cursor: default;
        }

        .red-suit { color: #dc2626; }
        
        /* Highlight for playable clock cards */
        .playable-card > .card {
            box-shadow: 0 0 15px 5px #facc15, 0 4px 6px rgba(0, 0, 0, 0.5);
            transform: scale(1.05);
            z-index: 10;
        }
        
        /* Highlight drop target: Apply to container or card */
        .center-stack-container.drop-target {
            background-color: #10b981 !important; /* Green glow for drop */
            border-color: #059669 !important;
            box-shadow: 0 0 15px 5px #10b981 !important;
        }

        /* Highlight for playable reserve card (when blocked) */
        .center-stack-container.reserve-available {
            box-shadow: 0 0 15px 5px #3b82f6; /* Blue glow */
            cursor: pointer; /* Change cursor to indicate clickability */
            pointer-events: auto;
        }
        
        /* CRITICAL FIX: Make all child cards transparent to clicks when the reserve is available, 
           so the click event reaches the reserve-available container beneath them. */
        .center-stack-container.reserve-available > .card-in-stack,
        .center-stack-container.reserve-available > .card-stack {
            pointer-events: none;
        }

        /* --- ABSOLUTE POSITIONING FIX FOR CLIPPING --- */
        .card-corner {
            position: absolute;
            display: flex;
            flex-direction: column;
            line-height: 1;
            padding: 4px; 
            z-index: 10;
            pointer-events: none;
        }
        
        /* Shared Text Styling */
        .card-corner .rank-text {
            font-size: 0.875rem; 
            font-weight: bold;
        }
        .card-corner .suit-icon {
            font-size: 1.125rem; 
        }

        /* Top Left Position */
        .card-corner.top-left {
            top: 0;
            left: 0;
            align-items: flex-start;
        }

        /* Bottom Right Position (Rotated) */
        .card-corner.bottom-right {
            bottom: 0;
            right: 0;
            align-items: flex-end; 
            transform: rotate(180deg);
        }

        /* Center Suit Icon */
        .center-suit-icon {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }


        /* Mobile-Specific Styles (For screens max 640px) */
        @media (max-width: 640px) {
            .clock-position, .center-stack-container {
                width: 55px; 
                min-height: 82px; 
            }
            
            .card-in-stack {
                height: 82px; /* Fixed mobile height */
            }

            .card-corner {
                padding: 3px; 
            }

            .card-corner .rank-text {
                font-size: 0.75rem; 
            }

            .card-corner .suit-icon {
                font-size: 0.875rem; 
            }
        }

    </style>
</head>
<body class="p-4">

    <div id="app">
        <h1 class="text-3xl font-extrabold text-white mb-4">Clock Tower Solitaire</h1>
        
        <div id="game-area">
            <div id="center-stacks" class="flex gap-8 md:gap-12">
                <!-- Center stack A and B containers -->
                <div class="flex flex-col items-center">
                    <p class="text-sm text-gray-400 mb-1">Stack A</p>
                    <div id="center-stack-A" class="center-stack-container" data-stack-key="A"></div>
                </div>
                <div class="flex flex-col items-center">
                    <p class="text-sm text-gray-400 mb-1">Stack B</p>
                    <div id="center-stack-B" class="center-stack-container" data-stack-key="B"></div>
                </div>
            </div>
        </div>

        <div id="status-bar" class="mt-4 p-4 bg-gray-700 rounded-xl shadow-lg text-white w-full max-w-sm text-center">
            <p id="message" class="text-lg font-semibold">Click 'New Game' to begin!</p>
            <p id="moves-left" class="text-sm mt-1 text-gray-400"></p>
        </div>

        <button onclick="initializeGame()" 
                class="mt-6 px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-bold text-lg rounded-full shadow-xl transition duration-300 transform hover:scale-105 active:scale-95">
            New Game
        </button>
    </div>

    <script>
        // --- Game Variables and Constants ---
        let deck = [];
        let clockStacks = []; 
        let centerStacks = { A: [], B: [] };
        let gameActive = false;
        let playableClockCardsCount = 0; 

        // --- Drag and Drop State ---
        let draggingCard = null; 
        let draggingCardData = null; 
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // Constants
        const suits = ['â™¥', 'â™¦', 'â™£', 'â™ '];
        const rankNames = { 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };
        const centerStackIds = ['center-stack-A', 'center-stack-B'];
        const CARD_HEIGHT = 120; // Must match CSS .card-in-stack height
        // INCREASED OFFSET FOR BETTER VISIBILITY
        const STACK_OFFSET = 6;  // 6px offset for visual stacking

        /**
         * Converts a rank number (1-13) to its display name (A, 2, ..., K).
         * @param {number} rank 
         * @returns {string}
         */
        function getRankName(rank) {
            return rankNames[rank] || String(rank);
        }
        
        /**
         * Creates a standard 52-card deck.
         * @returns {Array<object>} The shuffled deck.
         */
        function createDeck() {
            const newDeck = [];
            for (const suit of suits) {
                for (let rank = 1; rank <= 13; rank++) {
                    newDeck.push({
                        rank: rank,
                        suit: suit,
                        value: rank, 
                        isFaceUp: false,
                        id: `${getRankName(rank)}${suit}`
                    });
                }
            }
            return newDeck;
        }

        /**
         * Shuffles an array (Fisher-Yates algorithm).
         * @param {Array} array 
         */
        function shuffle(array) {
            if (!Array.isArray(array)) {
                console.error("Shuffle function requires an array.");
                return []; 
            }
            
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; 
            }
        }

        /**
         * Determines if a move is valid based on the +1/-1 rule (including King-Ace wrap).
         * @param {number} movingVal The value of the card being moved (1-13).
         * @param {number} targetVal The value of the top card on the center stack (1-13).
         * @returns {boolean}
         */
        function isValidMove(movingVal, targetVal) {
            const rankDiff = Math.abs(movingVal - targetVal);

            // 1. Check for sequential difference (+1 or -1)
            if (rankDiff === 1) {
                return true;
            }

            // 2. Check for King-Ace wrap-around (13 on 1, or 1 on 13)
            const isKOnA = movingVal === 13 && targetVal === 1;
            const isAOnK = movingVal === 1 && targetVal === 13;

            if (isKOnA || isAOnK) {
                return true;
            }
            
            return false;
        }

        // --- DOM Rendering Functions ---

        /**
         * Renders a single card element, wrapped in a card-in-stack container for positioning.
         * @param {object} card 
         * @param {boolean} isDraggable True if the card can be dragged.
         * @param {string} stackId The ID of the stack the card belongs to.
         * @param {number} cardIndex The index within the stack.
         * @param {number} zIndex The z-index for stacking.
         * @param {number} offsetY The vertical offset (in px) for stacking.
         * @returns {string} The HTML string for the card.
         */
        function renderCard(card, isDraggable, stackId, cardIndex, zIndex, offsetY) {
            if (!card) return '';

            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            const suitColor = isRed ? 'red-suit' : 'text-black';
            const draggableClass = isDraggable ? 'draggable playable-card' : '';
            
            // Apply position and depth styles
            const stackStyles = `z-index: ${zIndex}; transform: translateY(${offsetY}px);`;

            let cardContent = '';
            
            if (card.isFaceUp) {
                cardContent = `
                    <div class="card ${suitColor}">
                        <!-- Top Left Corner -->
                        <div class="card-corner top-left">
                            <span class="rank-text">${getRankName(card.rank)}</span>
                            <span class="suit-icon">${card.suit}</span>
                        </div>
                        
                        <!-- Center Suit -->
                        <div class="center-suit-icon">
                            <span class="text-4xl ${suitColor}">${card.suit}</span>
                        </div>
                        
                        <!-- Bottom Right Corner (Rotated 180deg) -->
                        <div class="card-corner bottom-right">
                            <span class="rank-text">${getRankName(card.rank)}</span>
                            <span class="suit-icon">${card.suit}</span>
                        </div>
                    </div>
                `;
            } else {
                cardContent = `<div class="card face-down"></div>`;
            }
            
            // Wrap the visual card in the positioning container
             return `
                <div class="card-in-stack ${draggableClass}" style="${stackStyles}"
                     data-stack-id="${stackId}" 
                     data-card-index="${cardIndex}"
                     data-rank="${card.rank}"
                     data-value="${card.value}">
                     ${cardContent}
                </div>
            `;
        }

        /**
         * Renders the 12 clock stacks in a circular arrangement, showing card depth.
         */
        function renderClockStacks() {
            const gameArea = document.getElementById('game-area');
            // Remove existing clock positions before re-rendering
            gameArea.querySelectorAll('.clock-position').forEach(el => el.remove());

            // 1. Calculate Radius
            const areaSize = Math.min(gameArea.clientWidth, gameArea.clientHeight);
            const radius = areaSize * 0.45;
            
            clockStacks.forEach((stack, index) => {
                const hour = index + 1;
                const angle = (hour / 12) * 2 * Math.PI;
                const x = radius * Math.sin(angle);
                const y = -radius * Math.cos(angle); 

                const positionDiv = document.createElement('div');
                positionDiv.id = `clock-stack-${hour}`;
                positionDiv.className = 'clock-position transform -translate-x-1/2 -translate-y-1/2';
                positionDiv.style.left = `50%`;
                positionDiv.style.top = `50%`;
                positionDiv.style.transform = `translate(calc(${x}px - 50%), calc(${y}px - 50%))`;
                
                let stackHTML = '';

                if (stack.length > 0) {
                    // Adjust height of container to show stacked cards
                    const requiredHeight = CARD_HEIGHT + (stack.length - 1) * STACK_OFFSET;
                    // Max height is set in CSS, but we set the calculated height here
                    positionDiv.style.height = `${requiredHeight}px`;

                    // Iterate from bottom card (index 0) up to the top card
                    stack.forEach((card, cardIndex) => {
                        // Only the topmost card can be draggable
                        const isDraggable = cardIndex === stack.length - 1 && card.isFaceUp && gameActive;
                        const zIndex = cardIndex + 1;
                        const offsetY = cardIndex * STACK_OFFSET; 

                        stackHTML += renderCard(
                            card, 
                            isDraggable, 
                            `clock-stack-${hour}`, 
                            cardIndex, 
                            zIndex, 
                            offsetY
                        );
                    });
                    positionDiv.innerHTML = stackHTML;

                } else {
                    // If stack is empty, use the empty card-stack div (placeholder)
                    positionDiv.innerHTML = '<div class="card-stack"></div>';
                    positionDiv.style.height = `${CARD_HEIGHT}px`; // Reset height
                }
                
                gameArea.appendChild(positionDiv);
            });
        }

        /**
         * Renders the two center stacks, showing the edge of remained cards.
         */
        function renderCenterStacks() {
            centerStackIds.forEach(id => {
                const stackElement = document.getElementById(id);
                const stackKey = stackElement.dataset.stackKey;
                const stack = centerStacks[stackKey] || []; 

                let innerHTMLContent = '';

                if (stack.length === 0) {
                    innerHTMLContent = '<div class="card-stack"></div>';
                    stackElement.style.height = `${CARD_HEIGHT}px`; // Reset height
                } else {
                    // Adjust height of container to show stacked cards
                    const requiredHeight = CARD_HEIGHT + (stack.length - 1) * STACK_OFFSET;
                    stackElement.style.height = `${requiredHeight}px`;

                    // Iterate from bottom card (index 0) to top (index length - 1)
                    stack.forEach((card, cardIndex) => {
                        // All center cards are targets, not draggable
                        const isDraggable = false; 
                        const zIndex = cardIndex + 1;
                        const offsetY = cardIndex * STACK_OFFSET;
                        
                        // Create a mutable copy of the card data for rendering
                        const cardToRender = {...card};
                        
                        // Rules for face-up status in center stack:
                        // 1. Index 0 (Reserve) keeps its status (false until activated).
                        // 2. All others (played cards, index > 0) are shown face-up.
                        if (cardIndex > 0) {
                            cardToRender.isFaceUp = true;
                        }

                        innerHTMLContent += renderCard(
                            cardToRender, 
                            isDraggable, 
                            id, 
                            cardIndex, 
                            zIndex, 
                            offsetY
                        );
                    });
                }
                
                // Clear any previous classes and re-apply during status update
                stackElement.classList.remove('reserve-available', 'drop-target'); // Clear drop-target here too
                stackElement.innerHTML = innerHTMLContent;
            });
        }
        
        /**
         * Checks if the reserve card (index 0) exists and is still face-down.
         * @param {Array<object>} stack 
         * @returns {boolean}
         */
        function hasReserve(stack) {
            return stack.length > 0 && stack[0] && !stack[0].isFaceUp;
        }

        /**
         * Handles the click event on a center stack to activate both reserve cards (Combined Reserve Rule).
         * @param {Event} e 
         */
        function handleCenterStackClick(e) {
            if (!gameActive || draggingCard) {
                console.log("Reserve click failed: Game not active or currently dragging.");
                return;
            }

            const target = e.target.closest('.center-stack-container');
            if (!target) return;
            
            // Only Stack A is designed to be the interactive element for combined activation
            if (target.id !== 'center-stack-A') return; 

            if (!target.classList.contains('reserve-available')) {
                document.getElementById('message').textContent = `The Reserve is not yet available. You must play all available clock moves first.`;
                console.log("Reserve click failed: Reserves either used or unavailable or moves are available.");
                return;
            } 
            
            if (playableClockCardsCount > 0) {
                document.getElementById('message').textContent = `Move available! You must play the highlighted card(s) before using the reserve.`;
                console.log("Reserve click failed: Playable clock cards exist. Count:", playableClockCardsCount);
                return;
            }

            const reserveAvailableA = hasReserve(centerStacks.A);
            const reserveAvailableB = hasReserve(centerStacks.B);
            
            if (reserveAvailableA && reserveAvailableB) {
                // --- Execute Combined Reserve Flip for Stack A and B ---
                
                const discardedCountA = centerStacks.A.length - 1;
                const discardedCountB = centerStacks.B.length - 1;

                // Splice(1) removes all elements starting from index 1 (the played cards)
                centerStacks.A.splice(1); 
                centerStacks.B.splice(1);
                
                // Flip the remaining reserve card (now index 0) face-up
                centerStacks.A[0].isFaceUp = true; 
                centerStacks.B[0].isFaceUp = true;

                console.log(`Reserves activated. Discarded ${discardedCountA} cards from A and ${discardedCountB} cards from B.`);

                document.getElementById('message').textContent = `RESERVES ACTIVATED! The face-up Reserve Cards are now the new target cards. Look for moves!`;
                
                renderCenterStacks();
                updateStatus();
            } else {
                 document.getElementById('message').textContent = `Reserve cards are missing or already used.`;
            }
        }
        
        // --- Game Setup and Status ---

        /**
         * Gets the value of the topmost face-up card on a center stack, or null if no face-up card is available.
         * @param {Array<object>} stack 
         * @returns {number | null}
         */
        function getPlayableCenterCardValue(stack) {
            const topCard = stack[stack.length - 1];
            // Must check if the top card is face-up (it will be, unless it's the unactivated reserve, but checking is safe)
            return topCard && topCard.isFaceUp ? topCard.value : null;
        }

        /**
         * Updates the game message and moves counter, and applies the playable highlights.
         */
        function updateStatus() {
            // Calculate remaining clock cards
            let totalClockCards = clockStacks.reduce((sum, stack) => sum + stack.length, 0);
            let totalCenterCards = centerStacks.A.length + centerStacks.B.length;

            document.getElementById('moves-left').textContent = `Clock cards remaining: ${totalClockCards} | Center stacks total: ${totalCenterCards}`;

            if (!gameActive) return;

            // 1. Determine playable clock cards 
            const centerTopA = getPlayableCenterCardValue(centerStacks.A);
            const centerTopB = getPlayableCenterCardValue(centerStacks.B);

            playableClockCardsCount = 0;
            
            for (let i = 1; i <= 12; i++) {
                const stack = clockStacks[i - 1];
                const topCard = stack[stack.length - 1];
                const cardElementContainer = document.getElementById(`clock-stack-${i}`);
                // Select the top card for highlighting
                const cardElement = cardElementContainer ? cardElementContainer.querySelector(`.card-in-stack[data-card-index="${stack.length - 1}"]`) : null;
                
                // Clear highlight from all cards first
                if (cardElement) { cardElement.classList.remove('playable-card'); }

                if (topCard && topCard.isFaceUp) {
                    let isPlayable = (centerTopA !== null && isValidMove(topCard.value, centerTopA)) || 
                                     (centerTopB !== null && isValidMove(topCard.value, centerTopB));
                    
                    if (isPlayable) {
                        if (cardElement) {
                             cardElement.classList.add('playable-card');
                        }
                        playableClockCardsCount++;
                    }
                }
            }
            
            // 2. Determine Reserve Availability/Usage
            
            const reserveAvailableA = hasReserve(centerStacks.A);
            const reserveAvailableB = hasReserve(centerStacks.B);
            const bothReservesAvailable = reserveAvailableA && reserveAvailableB;
            
            centerStackIds.forEach(id => {
                const stackElement = document.getElementById(id);
                // Remove existing highlights first
                stackElement.classList.remove('reserve-available', 'drop-target');

                if (playableClockCardsCount === 0 && totalClockCards > 0 && bothReservesAvailable && id === 'center-stack-A') {
                    stackElement.classList.add('reserve-available');
                    stackElement.title = "Click to activate both Reserves!";
                } else {
                    stackElement.title = "";
                }
            });

            // 3. Handle Game Status Messages
            if (totalClockCards === 0) {
                document.getElementById('message').textContent = 'ðŸŽ‰ YOU WON! CONGRATULATIONS! You cleared the Clock Tower!';
                gameActive = false;
            } else if (playableClockCardsCount === 0) {
                if (bothReservesAvailable) { 
                    document.getElementById('message').textContent = 'BLOCKED! Click the glowing blue Stack A to activate BOTH Reserve Cards simultaneously.';
                } else {
                    document.getElementById('message').textContent = 'ðŸ’€ GAME OVER! No more valid moves and no reserves left.';
                    gameActive = false;
                }
            } else {
                document.getElementById('message').textContent = draggingCardData 
                    ? `Dragging ${getRankName(draggingCardData.card.rank)}${draggingCardData.card.suit}. Drop on a green target.`
                    : 'Drag a glowing card (+1 or -1 to center stack).';
            }
            
            // 4. Highlight Drop Targets (during drag)
            if (draggingCardData) {
                centerStackIds.forEach(id => {
                    const stackElement = document.getElementById(id);
                    
                    const stackKey = stackElement.dataset.stackKey;
                    const targetStack = centerStacks[stackKey];
                    
                    const targetCardValue = getPlayableCenterCardValue(targetStack);

                    if (targetCardValue !== null && draggingCardData.card && isValidMove(draggingCardData.card.value, targetCardValue)) {
                        stackElement.classList.add('drop-target');
                    }
                });
            }
        }

        /**
         * Sets up the initial game state.
         */
        function initializeGame() {
            deck = createDeck();
            shuffle(deck); 
            
            clockStacks = [];
            centerStacks = { A: [], B: [] }; 
            gameActive = true;
            draggingCard = null;
            draggingCardData = null;
            playableClockCardsCount = 0; 

            // 1. Distribute 4 cards to 12 clock locations (48 cards)
            for (let i = 0; i < 12; i++) {
                clockStacks.push(deck.splice(0, 4));
            }

            // 2. Distribute 2 cards to 2 center stacks (4 cards)
            centerStacks.A = deck.splice(0, 2);
            centerStacks.B = deck.splice(0, 2);
            
            // 3. Flip the surface cards
            clockStacks.forEach(stack => {
                if (stack.length > 0) {
                    stack[stack.length - 1].isFaceUp = true;
                }
            });
            
            // Center cards: bottom (0) down, top (1) up
            if (centerStacks.A.length === 2) {
                centerStacks.A[0].isFaceUp = false; // Reserve card
                centerStacks.A[1].isFaceUp = true; // Playable card
            }
            if (centerStacks.B.length === 2) {
                centerStacks.B[0].isFaceUp = false; // Reserve card
                centerStacks.B[1].isFaceUp = true; // Playable card
            }

            // Set up event listeners (only run once)
            document.removeEventListener('mousedown', startDragGlobal);
            document.removeEventListener('touchstart', startDragGlobal);
            document.removeEventListener('mousemove', doDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', doDrag);
            document.removeEventListener('touchend', endDrag);

            document.addEventListener('mousedown', startDragGlobal);
            document.addEventListener('touchstart', startDragGlobal, { passive: false });
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', doDrag, { passive: false }); 
            document.addEventListener('touchend', endDrag);

            const centerStacksEl = document.getElementById('center-stacks');
            if (centerStacksEl) {
                centerStacksEl.removeEventListener('click', handleCenterStackClick); 
                centerStacksEl.addEventListener('click', handleCenterStackClick);
            }


            renderClockStacks();
            renderCenterStacks();
            updateStatus();
            
            document.getElementById('message').textContent = 'Game started! Drag a glowing card to a center stack.';
        }

        // --- Drag and Drop Logic ---

        /**
         * Gets the client coordinates from a mouse or touch event.
         */
        function getEventCoords(e) {
            const touch = e.touches?.[0] || e.changedTouches?.[0] || e;
            return { x: touch.clientX, y: touch.clientY };
        }

        /**
         * Global listener to start the drag, using event delegation.
         */
        function startDragGlobal(e) {
            if (!gameActive || draggingCard) return;

            // Find the playable card element that initiated the event
            const cardElement = e.target.closest('.card-in-stack.draggable');
            
            // Check if it's the top card and is playable (highlighted)
            if (!cardElement || !cardElement.classList.contains('playable-card')) return;

            if (e.type === 'touchstart' || e.type === 'mousedown') {
                 e.preventDefault(); 
            }
            
            // Setup card reference and state
            draggingCard = cardElement;
            
            // Find data in game state
            const stackId = draggingCard.dataset.stackId;
            const hour = parseInt(stackId.split('-')[2]);
            const stackIndex = hour - 1;
            const stack = clockStacks[stackIndex];
            const card = stack[stack.length - 1];

            // Get coordinates and position details
            const coords = getEventCoords(e);
            const rect = draggingCard.getBoundingClientRect();
            
            dragOffsetX = coords.x - rect.left;
            dragOffsetY = coords.y - rect.top;
            
            // Capture and apply explicit pixel dimensions to prevent resizing
            const widthPx = draggingCard.offsetWidth;
            const heightPx = draggingCard.offsetHeight;
            
            draggingCard.style.width = `${widthPx}px`;
            draggingCard.style.height = `${heightPx}px`;

            // Store original position and stack data
            draggingCardData = { 
                card: card, 
                stack: stack, 
                stackIndex: stackIndex, 
                originalContainer: draggingCard.parentNode,
            };
            
            // Apply drag styles and position (use fixed for full screen coverage)
            draggingCard.classList.add('dragging');
            draggingCard.style.position = 'fixed';
            draggingCard.style.left = `${coords.x - dragOffsetX}px`;
            draggingCard.style.top = `${coords.y - dragOffsetY}px`;
            
            // Move card to the body to ensure it stays above all other elements
            document.body.appendChild(draggingCard);

            updateStatus(); // Update status to highlight drop targets
        }


        /**
         * Updates the card's position during drag.
         */
        function doDrag(e) {
            if (!draggingCard) return;
            if (e.type.startsWith('touch')) e.preventDefault();

            const coords = getEventCoords(e);
            
            draggingCard.style.left = `${coords.x - dragOffsetX}px`;
            draggingCard.style.top = `${coords.y - dragOffsetY}px`;
            
            updateStatus();
        }
        
        /**
         * Ends the drag operation and processes the move or resets the card.
         */
        function endDrag(e) {
            if (!draggingCard) return;
            
            const coords = getEventCoords(e);
            let moveExecuted = false;

            const tempDraggingCard = draggingCard;
            const tempDraggingCardData = draggingCardData;
            
            // Temporarily hide the dragging card so elementFromPoint sees the target beneath it
            tempDraggingCard.style.visibility = 'hidden'; 
            const elementBelow = document.elementFromPoint(coords.x, coords.y);
            tempDraggingCard.style.visibility = 'visible'; // Restore visibility

            // Find the center stack container 
            const targetStackContainer = elementBelow ? elementBelow.closest('.center-stack-container') : null;
            
            if (targetStackContainer && tempDraggingCardData) {
                const stackKey = targetStackContainer.dataset.stackKey;
                const targetStack = centerStacks[stackKey];
                
                const targetCardValue = getPlayableCenterCardValue(targetStack);
                const movingVal = tempDraggingCardData.card.value;

                if (targetCardValue !== null && isValidMove(movingVal, targetCardValue)) {
                    handleMoveExecution(stackKey, tempDraggingCardData);
                    moveExecuted = true;
                }
            }
            
            // 2. Perform cleanup 
            tempDraggingCard.classList.remove('dragging', 'playable-card');
            tempDraggingCard.style.position = '';
            tempDraggingCard.style.left = '';
            tempDraggingCard.style.top = '';
            tempDraggingCard.style.width = '';
            tempDraggingCard.style.height = '';


            // 3. Clear global drag state
            draggingCard = null;
            draggingCardData = null;
            dragOffsetX = 0;
            dragOffsetY = 0;

            if (!moveExecuted && tempDraggingCardData) {
                const movingCardName = getRankName(tempDraggingCardData.card.rank);
                document.getElementById('message').textContent = `Invalid drop! ${movingCardName} must be exactly +1 or -1 of the currently visible target card.`;
            }

            // 4. Remove the element from the body (it will be recreated by the subsequent render)
            if (tempDraggingCard.parentNode === document.body) {
                document.body.removeChild(tempDraggingCard);
            }
            
            // Final render to update state
            renderClockStacks();
            renderCenterStacks();
            updateStatus();
        }

        /**
         * Executes the game logic for a valid drop.
         * @param {string} stackKey 'A' or 'B'
         * @param {object} cardData The dragging card's data, including its origin stack.
         */
        function handleMoveExecution(stackKey, cardData) {
            const targetStack = centerStacks[stackKey] || [];
            const movingCard = cardData.card;

            // 1. Execute the move
            cardData.stack.pop(); // Remove from clock stack
            targetStack.push(movingCard); // Add to center stack
            
            // 2. Flip the new top card of the clock stack (if exists)
            const newTopCard = cardData.stack[cardData.stack.length - 1];
            if (newTopCard) {
                newTopCard.isFaceUp = true;
            }
            
            document.getElementById('message').textContent = `Played ${getRankName(movingCard.rank)}${movingCard.suit} on Center Stack ${stackKey}.`;
        }


        window.onload = initializeGame;

        // Recalculate positions on resize (responsive circle)
        window.addEventListener('resize', () => {
             if (gameActive) {
                renderClockStacks();
             }
        });
        
    </script>
</body>
</html>
